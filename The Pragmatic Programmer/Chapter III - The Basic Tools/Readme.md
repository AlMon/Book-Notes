Chapter III - The Basic Tools:

- Tools amplify your talent.
- Start with a basic set of more generalist tools and expect to add to your toolbox regularly.
- Let need be the drive behind new acquisitions.
- Our IDEs can be used as a crutch and that's a mistake.
- The palest ink is still better than the best memory.
- The aim is to let tools become extensions of your hands through mastery.
- Plain text is the quintessential tool of our trade, it bridges the gap between man and computer.
- Our shell of choice is analogous to a woodworker's workbench.
- Using the shell to launch, access and manipulate our programs and files can be very beneficial.
- The problem with using a GUI is pretty much the same as its main benefit: WYSIWYG.
- A shell, like all other tools, should be customized to fit the developer.
- The productivity gains obtained by using your shell instead of a GUI can be sizeable.
- Instead of wanting to learn all of your editor's commands, learn those that make your life easier.
- Progress, far from consisting in change, depends on retentiveness.
- A Version Control System is analogous to one giant undo key.
- Shared Directories are not a Version Control System.
- Do not use a VCS alongside a cloud solution - corruption is constant and pretty much inevitable.
- Another benefit of VCSs is that they allow to keep track of all changes and answer questions thereof.
- Always use Version Control, regardless of size and scope of project.
- A strong benefit of VCS branches is isolation.
- The origin of the word "bug" is literal, it comes from a moth getting stuck in a machine that made it function improperly.
- Embrace the fact that debugging is just problem-solving and approach it as such.
- Concentrate on fixing the problem, not placing the blame.
- Don't panic and never think that "it's impossible" as that's never the case.
- Artificial tests are important to run first, but not omnipotent.
- If a bug proves to be particularly naughty, interview the bug reporter to gain insight.
- Use Binary Chops to place limits in the amounts of troubling data if there's a data error that's complicated.
- "Rubber Ducking" - explaining the issue as you tell the story of the code step-by-step to another person, is often invaluable for debugging.
- If you don't have another person handy for Rubber Ducking, even an inanimate object or a pet will do.
- "Select Is Not Broken" don't blame the underlying system or a 3rd party API, the issue is rarely there.
- The amount of surprise that you have at a bug is proportionate to the amount of faith you have on a program's elements.
- If you get a big surprise, check your assumptions and the code more closely.
- Don't assume it - prove it.
- The Debugging Checklist:
  - Is the problem being reported a direct result of the underlying bug, or merely a symptom?
  - Is the bug really in the compiler? Is it in the OS? Or is it in your code?
  - If you explained this problem in detail to a coworker, what would you say?
  - If the suspect code passes its unit tests, are the tests complete enough? What happens if you run the unit test with this data?
  - Do the conditions that caused this bug exist anywhere else in the system?
- Create Engineering Daybooks - record what you did, what you learn, sketch ideas and readings from meters.
- All software becomes legacy as soon as its written.
